/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipex.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jgravalo <jgravalo@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/11/24 17:13:06 by jgravalo          #+#    #+#             */
/*   Updated: 2023/02/12 18:36:28 by jgravalo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h" 


//int pipex(char *comm, char **src, char **envp, char *dst)
int pipex(char **comm, char **src, char **envp, char *dst, int n)
{
	pid_t	pid1;
	pid_t	pid2;
	int		a[2];
	int		b[2];

	pipe(a);
	pipe(b);
	pid1 = fork();
	pid2 = fork();
	if (pid1 == 0)
	{ // hijo
		child(a, comm[1], src, envp, n);
	}
	src[1] = dst;
	if (pid2 == 0)
	{ // hijo
		child2(a, b, comm[2], src, envp, n);
	}
	else
	{ // padre
		father(a, b, dst, n);
//		father(a, b, dst);
	}
	waitpid(pid1, NULL, 0);
	waitpid(pid2, NULL, 0);
	return (0);
}



void	child(int a[], char *comm, char **src, char **envp, int n)
//void	child(int a[], int b[], char *comm, char **src, char **envp)
{
	int exec;

	close(a[0]); /* cerramos el lado de lectura del hijo */
//	write(1, "\n\nestoy en pid==0\n", 18);// BORRAR !!!
	dup2(a[1], 1);
//	dup2(b[1], 2);
	close(a[1]);
//	unlink(src[1]);
	exec = exec_comm(comm, src, envp, n);
	if (exec == -1)
		write(1, "exec=error\n", 11);
}

void	child2(int a[], int b[], char *comm, char **src, char **envp, int n)
//void	child(int a[], int b[], char *comm, char **src, char **envp)
{
	int exec;
	int		readbytes;
	char	buffer[SIZE];

	close(a[1]); /* cerramos el lado de escritura del padre */
	close(b[0]); /* cerramos el lado de lectura del hijo */
//	write(1, "\n\nestoy en pid==0\n", 18);// BORRAR !!!
	readbytes = read(a[0], buffer, SIZE);
	while (readbytes > 0)
	{
		write(b[1], buffer, readbytes);// BORRAR !!!
		readbytes = read(a[0], buffer, SIZE);
	}
	close(a[0]);
	dup2(b[1], 1);
//	dup2(a[1], 2);
//	close(fd);
//	unlink(src[1]);
	exec = exec_comm(comm, src, envp, n);
	if (exec == -1)
		write(1, "exec=error\n", 11);
}

void	father(int a[], int b[], char *dst, int n)
//void	father(int a[], int b[], char *dst)
{
	int		readbytes;
	int		fd;
	char	buffer[SIZE];

	if (n == -1)
	   exit(0);	
	close(a[0]); /* cerramos el lado de lectura del padre */
	close(b[1]); /* cerramos el lado de escritura del hijo */
//	write(1, "\n\nestoy en pid==1\n", 18);// BORRAR !!!
	close(a[1]);
	readbytes = read(b[0], buffer, SIZE);
	fd = open(dst, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR
		| S_IWUSR | S_IRGRP | S_IROTH);
	while (readbytes > 0)
	{
		write(1, buffer, readbytes);// BORRAR !!!
		write(fd, buffer, readbytes);
		readbytes = read(b[0], buffer, SIZE);
	}
	close(b[0]);
}

char    **makesrc(char **argv)
{
	char **src;

	src = (char **)malloc(sizeof(char *) * 3);
	src[0] = argv[0];
	src[1] = argv[1];
	src[2] = NULL;
	return (src);
}

char	**make_commands(int argc, char **argv)
{
	char    **command;
	int		i;

	command = (char **)malloc(((argc - 3) * sizeof(char)) + 8);
	i = 2;
	while (i < argc - 1)
	{
		command[i - 1] = argv[i];
		i++;
	}
	return (command);
}
